<?php

declare(strict_types=1);

namespace Drupal\acquia_migrate\Clusterer\Heuristics;

use Drupal\Component\Plugin\PluginBase;
use Drupal\migrate\Plugin\Migration as MigrationPlugin;
use Drupal\migrate\Plugin\MigrationInterface;

/**
 * Adds migration plugins depending on a content entity cluster to that cluster.
 *
 * @see \Drupal\acquia_migrate\Clusterer\Heuristics\ContentEntityBundles
 * @see \Drupal\acquia_migrate\Clusterer\Heuristics\ContentEntityBundlesDependencies
 */
abstract class ContentEntityDepending implements DependentHeuristicWithComputedDependentClusterInterface {

  use EntityRelatedHeuristicTrait;

  /**
   * {@inheritdoc}
   */
  abstract public static function id() : string;

  /**
   * {@inheritdoc}
   */
  public function getDependencies() : array {
    return [
      ContentEntityBundles::id(),
      ContentEntityBundlesDependencies::id(),
      PushedToModerationFlow::id(),
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function matches(MigrationPlugin $migration_plugin, array $dependent_heuristic_matches) : bool {
    $entity_migrations_plus_dependencies = array_merge(
      $dependent_heuristic_matches[ContentEntityBundles::id()],
      $dependent_heuristic_matches[ContentEntityBundlesDependencies::id()],
      $dependent_heuristic_matches[PushedToModerationFlow::id()],
      // F.e.: d7_comment_entity_display depends on d7_comment_field_instance.
      $dependent_heuristic_matches[static::id()]
    );
    $required_dependencies = $migration_plugin->getMigrationDependencies()['required'];
    $clustered_dependees = array_intersect($entity_migrations_plus_dependencies, $required_dependencies);
    $is_cluster_depender = !empty($clustered_dependees);
    $is_non_dependee = empty($migration_plugin->getMetadata('before'));
    $is_pure_cluster_depender = $is_cluster_depender && count($clustered_dependees) === count($required_dependencies);

    return $is_cluster_depender && ($is_pure_cluster_depender || $is_non_dependee);
  }

  /**
   * {@inheritdoc}
   */
  public function computeCluster(MigrationPlugin $migration_plugin, array $dependent_heuristic_matches, array $all_migration_plugins) : string {
    $entity_migrations_plus_dependencies = array_merge(
      $dependent_heuristic_matches[ContentEntityBundles::id()],
      $dependent_heuristic_matches[ContentEntityBundlesDependencies::id()],
      $dependent_heuristic_matches[PushedToModerationFlow::id()],
      $dependent_heuristic_matches[static::id()]
    );
    $clustered_dependees = array_intersect($entity_migrations_plus_dependencies, $migration_plugin->getMigrationDependencies()['required']);

    // When there are multiple clustered dependees, try picking one that is
    // more stable (less dependent on the outcome of core's migration plugin
    // graph-based sorting), by excluding the entity clusters.
    $stable_clustered_dependees = array_diff($clustered_dependees, array_keys($entity_migrations_plus_dependencies));
    if (!empty($stable_clustered_dependees) && count($stable_clustered_dependees) < count($clustered_dependees)) {
      if (count($stable_clustered_dependees) >= 1) {
        // @codingStandardsIgnoreStart
        \Drupal::logger('acquia_migrate')->debug('The @migration-id migration has multiple clustered dependees (@dependees), but even the stable subset (@stable-dependees) contains multiple cluster choices to push towards. Consider adding more heuristics for clustering, to avoid unstable cluster assignment. The stability of the current heuristic can be evaluated by analyzing these debug messages and observing whether the parentheticals ever have different orders.', [
          '@migration-id' => $migration_plugin->id(),
          '@dependees' => implode(', ', $clustered_dependees),
          '@stable-dependees' => implode(', ', $stable_clustered_dependees),
        ]);
        // @codingStandardsIgnoreEnd
      }
      $clustered_dependees = $stable_clustered_dependees;
    }
    // Push up towards the clustered dependee that runs last, to ensure all
    // dependencies continue to have been met by the time it will run.
    $migration_to_push_towards = end($clustered_dependees);

    // If the actual migration plugin's destination migration
    // ($migration_to_push_towards) was clustered by PushedToModerationFlow, we
    // try to identify the corresponding content entity migration to push it to.
    // Because we know that bundle config entities (e.g. `d7_node_type:*`) are
    // pushed into the clusters generated by PushedToModerationFlow, but we
    // still don't want _other_ migrations depending on bundle config entities
    // (e.g. `d7_node_type:*`) to also be pushed into clusters generated by
    // PushedToModerationFlow. For example `d7_rdf_mapping:node:*` was affected
    // by this.
    if (in_array($migration_to_push_towards, $dependent_heuristic_matches[PushedToModerationFlow::id()])) {
      $content_entity_bundle_migrations = array_intersect_key(
        $all_migration_plugins,
        array_flip($dependent_heuristic_matches[ContentEntityBundles::id()])
      );
      $matching_entity_bundle_cluster = static::computeDependentMigration($migration_to_push_towards, $content_entity_bundle_migrations);

      if (count($matching_entity_bundle_cluster) === 1) {
        $migration_to_push_towards = reset($matching_entity_bundle_cluster);
      }
    }

    // Look up the cluster of the dependee it's getting pushed to run after
    // and assign this same cluster.
    $cluster_to_push_towards = $all_migration_plugins[$migration_to_push_towards]->getMetadata('cluster');
    return (string) $cluster_to_push_towards;
  }

  /**
   * Identifies the dependent migration plugin of the given migration plugin ID.
   *
   * @param string $migration_plugin_id
   *   The migration whose corresponding migration plugin(s) should be
   *   identified.
   * @param \Drupal\migrate\Plugin\MigrationInterface[] $migrations
   *   Array of the migrations which can depend on the specified migration.
   * @param bool $strict_matching
   *   Whether the discovery should only match the given ID, or it should check
   *   for the base ID as well.
   *
   * @return string[]
   *   The identified migration IDs which depend on the given migration.
   */
  protected static function computeDependentMigration(string $migration_plugin_id, array $migrations, bool $strict_matching = TRUE): array {
    $corresponding_migrations = array_filter(
      $migrations,
      function (MigrationInterface $migration) use ($migration_plugin_id, $strict_matching) {
        $migration_deps = $migration->getMigrationDependencies();
        $migration_all_deps = array_unique(
          array_merge(
            $migration_deps['required'],
            $migration_deps['optional']
          )
        );

        $strict_match = in_array($migration_plugin_id, $migration_all_deps, TRUE);
        $baseid_match = in_array(explode(PluginBase::DERIVATIVE_SEPARATOR, $migration_plugin_id, 2)[0], $migration_all_deps, TRUE);

        return $strict_matching
          ? $strict_match
          : $strict_match || $baseid_match;
      }
    );

    return array_keys($corresponding_migrations);
  }

}
